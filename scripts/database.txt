//----- Variables -----------------------------------------------------------------------------------------------------

class = 28
count1 = 9
count2 = 0
dataIndex = 53402
i = 20
objectCount = 4210
objectsOffs = 1024
objectsSize = 106004
objSize = 27
parentObjectIndex = 22
property = 2172
propertyIndex = 648
propIndex = 53384
propIndex1 = 53402
propIndex2 = 53386
sourceS = 107028
textOffs = 512
textSize = 512
value = 1366
varObjectCount = 4210
_gameStateSize = 96
_mainCodeObjectIndex = 69
_objSize = 27


//----- Lists ---------------------------------------------------------------------------------------------------------

buffer = { }
ObjectV2::_freeData = { }
_gameText = { }


//----- Broadcast received events -------------------------------------------------------------------------------------

WhenBroadcastReceived(clear data)
{
    List.DeleteAll(_gameText);
    List.DeleteAll(buffer);
    List.DeleteAll(ObjectV2::_freeData);
    List.DeleteAll(ObjectV2::_objSize);
}

WhenBroadcastReceived(GameDatabase:open)
{
    sourceS = 0;
    Event.BroadcastAndWait("GameDatabaseV2::load");
}

WhenBroadcastReceived(GameDatabaseV2::GameDatabaseV2)
{
    Event.BroadcastAndWait("initialise _dat.list");
    List.DeleteAll(_gameState);
    List.DeleteAll(ObjectV2::_freeData);
    List.DeleteAll(ObjectV2::_objData);
    List.DeleteAll(ObjectV2::_objSize);
    List.DeleteAll(ObjectV2::objDataOffset);
    _gameStateSize = 0;
    _mainCodeObjectIndex = 0;
}

WhenBroadcastReceived(GameDatabaseV2::load)
{
    Call value = SeekableReadStream::readUint16LE;
    Call buffer = SeekableReadStream::read(6) bytes;
    Call value = SeekableReadStream::readUint16LE;
    Call SeekableReadStream::Skip(18);
    Call value = SeekableReadStream::readUint16LE;
    textOffs = (value * 512);
    Call value = SeekableReadStream::readUint16LE;
    objectCount = value;
    Call value = SeekableReadStream::readUint16LE;
    varObjectCount = value;
    Call value = SeekableReadStream::readUint16LE;
    _gameStateSize = (value * 2);
    Call value = SeekableReadStream::readUint16LE;
    Call value = SeekableReadStream::readUint16LE;
    objectsOffs = (value * 512);
    Call value = SeekableReadStream::readUint16LE;
    Call value = SeekableReadStream::readUint16LE;
    _mainCodeObjectIndex = value;
    Call value = SeekableReadStream::readUint16LE;
    Call value = SeekableReadStream::readUint16LE;
    objectsSize = (value * 2);
    textSize = (objectsOffs - textOffs);
    List.DeleteAll(_gameState);
    Repeat ((_gameStateSize + 2))
    {
        List.Add(_gameState, 0);
    }
    Call GameDatabase::setVar at index(1) with value(objectCount);
    Call SeekableReadStream::Seek(textOffs);
    List.DeleteAll(_gameText);
    Call buffer = SeekableReadStream::read(textSize) bytes;
    i = 1;
    Repeat (textSize)
    {
        List.Add(_gameText, (buffer[i] + 30));
        i += 1;
    }
    Call SeekableReadStream::Seek(objectsOffs);
    i = 0;
    Repeat (objectCount)
    {
        Call ObjectV2::ObjectV2 for object index(i);
        Call objSize = ObjectV2::Load from data index(sourceS) for object index(i);
        Call SeekableReadStream::Skip((objSize % 2));
        i += 1;
    }
}

WhenBroadcastReceived(RetunValue = GameDatabase::getObject(param1))
{
    ReturnValue = ObjectV2::objDataOffset[BroadcastParam1];
}

WhenBroadcastReceived(ReturnValue = GameDatabase::getObjectProperty(param1, param2))
{
    Call property = ObjectV2::getObjectProperty for objectIndex(BroadcastParam1) with propertyId(BroadcastParam2);
    ReturnValue = property;
}

WhenBroadcastReceived(ReturnValue = GameDatabase::setObjectProperty(param1, param2, param3))
{
    Call value = ObjectV2::setObjectProperty for objectIndex(BroadcastParam1) with propertyId(BroadcastParam2) to value(BroadcastParam3);
    ReturnValue = value;
}


//----- Custom blocks -------------------------------------------------------------------------------------------------

Define //(string comment) (warp=false)
{
}

Define //TODO(string comment) (warp=false)
{
    List.Add(DEBUG, comment);
    List.Show(DEBUG);
}

Define buffer = SeekableReadStream::read(string bytes) bytes (warp=true)
{
    List.DeleteAll(buffer);
    Repeat (bytes)
    {
        sourceS += 1;
        List.Add(buffer, _dat[sourceS]);
    }
}

Define class = ObjectV2::getClass for object#(string index) (warp=false)
{
    i = ObjectV2::objDataOffset[index];
    class = (ObjectV2::_objData[i] + (ObjectV2::_objData[(i + 1)] * 256));
}

Define count1 = ObjectV2::getCount1 for object#(string index) (warp=false)
{
    i = ObjectV2::objDataOffset[index];
    count1 = ObjectV2::_objData[(i + 2)];
}

Define count2 = ObjectV2::getCount2 for object#(string index) (warp=false)
{
    i = ObjectV2::objDataOffset[index];
    count2 = ObjectV2::_objData[(i + 3)];
}

Define dataIndex = GameDatabaseV2::findObjectProperty for objectIndex(string objectIndex) with propertyId(string propertyId) (warp=false)
{
    Call LOG(Operator.Join(Operator.Join(Operator.Join(Operator.Join("findObjectProperty(", objectIndex), ", "), propertyId), ")"));
    Call class = ObjectV2::getClass for object#(objectIndex);
    If (class > 32765)
    {
        Call ERROR("findObjectProperty: Not an object");
    }
    propIndex = (ObjectV2::objDataOffset[objectIndex] + 4);
    Call LOG(Operator.Join("class = ", class));
    Call count1 = ObjectV2::getCount1 for object#(objectIndex);
    Call count2 = ObjectV2::getCount2 for object#(objectIndex);
    Call LOG(Operator.Join("count1 = ", count1));
    Call LOG(Operator.Join("count2 = ", count2));
    i = 0;
    Repeat (((count1 + count2) * 2))
    {
        Call LOG(ObjectV2::_objData[(propIndex + i)]);
        i += 1;
    }
    propIndex1 = (propIndex + (count1 * 2));
    propIndex2 = (propIndex + (count2 * 2));
    Repeat Until (count2 == 0)
    {
        count2 += -1;
        Call LOG(Operator.Join("count2 = ", count2));
        Call LOG(Operator.Join("check propertyId against ", ((ObjectV2::_objData[propIndex] + (ObjectV2::_objData[(propIndex + 1)] * 256)) % 32768)));
        If (((ObjectV2::_objData[propIndex] + (ObjectV2::_objData[(propIndex + 1)] * 256)) % 32768) == propertyId)
        {
            Call LOG("Match!");
            dataIndex = propIndex1;
            Stop(this script);
        }
        propIndex += 2;
        propIndex1 += 2;
    }
    Call class = ObjectV2::getClass for object#(objectIndex);
    parentObjectIndex = class;
    If (parentObjectIndex == 0)
    {
        dataIndex = 0;
        Stop(this script);
    }
    Repeat Until (parentObjectIndex == 0)
    {
        Call LOG(Operator.Join("parentObjectIndex = ", parentObjectIndex));
        propIndex = (ObjectV2::objDataOffset[parentObjectIndex] + 4);
        Call count1 = ObjectV2::getCount1 for object#(parentObjectIndex);
        Call count2 = ObjectV2::getCount2 for object#(parentObjectIndex);
        Call LOG(Operator.Join("count1 = ", count1));
        Call LOG(Operator.Join("count2 = ", count2));
        i = 0;
        Repeat (((count1 + count2) * 2))
        {
            Call LOG(ObjectV2::_objData[(propIndex + i)]);
            i += 1;
        }
        propIndex1 = (propIndex2 + ((count1 - count2) * 2));
        propertyIndex = (propIndex + (count1 * 2));
        Repeat Until (count2 == 0)
        {
            count2 += -1;
            Call LOG(Operator.Join("count2 = ", count2));
            Call LOG(Operator.Join("check propertyId against ", (ObjectV2::_objData[propIndex] + (ObjectV2::_objData[(propIndex + 1)] * 256))));
            If ((ObjectV2::_objData[propIndex] + (ObjectV2::_objData[(propIndex + 1)] * 256)) < 32768)
            {
                If (((ObjectV2::_objData[propIndex] + (ObjectV2::_objData[(propIndex + 1)] * 256)) % 32768) == propertyId)
                {
                    Call LOG("Match1!");
                    dataIndex = propIndex1;
                    Stop(this script);
                }
                Else
                {
                    propIndex1 += 2;
                }
            }
            Else
            {
                If (((ObjectV2::_objData[propIndex] + (ObjectV2::_objData[(propIndex + 1)] * 256)) % 32768) == propertyId)
                {
                    Call LOG("Match2!");
                    dataIndex = propertyIndex;
                    Stop(this script);
                }
            }
            propIndex += 2;
            propertyIndex += 2;
        }
        Call class = ObjectV2::getClass for object#(parentObjectIndex);
        parentObjectIndex = class;
    }
    dataIndex = 0;
    Call LOG(Operator.Join(Operator.Join(Operator.Join(Operator.Join("findObjectProperty(", objectIndex), ", "), propertyId), ") Property not found"));
}

Define ERROR(string message) (warp=false)
{
    List.Add(DEBUG, message);
    List.Show(DEBUG);
    Stop(all);
}

Define GameDatabase::setVar at index(string index) with value(string value) (warp=false)
{
    List.ReplaceItem(_gameState, ((index * 2) + 1), (value % 256));
    List.ReplaceItem(_gameState, ((index * 2) + 2), floor((value / 256)));
}

Define LOG(string message) (warp=false)
{
    List.Add(LOG, message);
}

Define Not implemented yet(string comment) (warp=false)
{
    List.Add(DEBUG, comment);
    List.Show(DEBUG);
    Stop(all);
}

Define ObjectV2::ObjectV2 for object index(string index) (warp=true)
{
    If (Not ((index == List.Length(ObjectV2::_freeData))))
    {
        Call Not implemented yet("If we're not adding in sequential order then this will need more thinking!");
    }
    List.Add(ObjectV2::_freeData, False);
    List.Add(ObjectV2::_objSize, 0);
    List.Add(ObjectV2::objDataOffset, (List.Length(ObjectV2::_objData) + 1));
}

Define objSize = ObjectV2::Load from data index(string dataIndex) for object index(string index) (warp=true)
{
    If (ObjectV2::_freeData[(index + 1)] == True)
    {
        Call Not implemented yet("I'm assuming all objects are read in sequentially during load and that the sizes don't change subsequently");
    }
    List.ReplaceItem(ObjectV2::_freeData, (index + 1), False);
    Call value = SeekableReadStream::readUint16LE;
    If (value == 32767)
    {
        Call value = SeekableReadStream::readUint16LE;
        _objSize = value;
    }
    Else
    {
        If (value == 32766)
        {
            Call value = SeekableReadStream::readUint16LE;
            _objSize = (value * 2);
        }
        Else
        {
            Call value = SeekableReadStream::readUint16LE;
            _objSize = (((value % 256) + floor((value / 256))) * 2);
        }
    }
    _objSize += 4;
    List.ReplaceItem(ObjectV2::_objSize, (index + 1), _objSize);
    Call SeekableReadStream::Skip(-4);
    Call buffer = SeekableReadStream::read(4) bytes;
    Repeat (4)
    {
        List.Add(ObjectV2::_objData, buffer[1]);
        List.DeleteItem(buffer, 1);
    }
    Call buffer = SeekableReadStream::read((_objSize - 4)) bytes;
    Repeat ((_objSize - 4))
    {
        List.Add(ObjectV2::_objData, buffer[1]);
        List.DeleteItem(buffer, 1);
    }
    objSize = _objSize;
}

Define property = ObjectV2::getObjectProperty for objectIndex(string objectIndex) with propertyId(string propertyId) (warp=false)
{
    If (objectIndex == 0)
    {
        Call Not implemented yet("getObjectProperty: Returning zero (1)");
    }
    Call dataIndex = GameDatabaseV2::findObjectProperty for objectIndex(objectIndex) with propertyId(propertyId);
    If (dataIndex > 0)
    {
        property = (ObjectV2::_objData[dataIndex] + (ObjectV2::_objData[(dataIndex + 1)] * 256));
        Stop(this script);
    }
    Else
    {
        property = 0;
        Stop(this script);
    }
}

Define SeekableReadStream::Seek(string pos) (warp=false)
{
    sourceS = pos;
}

Define SeekableReadStream::Skip(string v) (warp=false)
{
    sourceS += v;
}

Define value = GameDatabase::getVar at index(string index) (warp=false)
{
    value = (_gameState[((index * 2) + 1)] + (_gameState[((index * 2) + 1)] * 256));
}

Define value = ObjectV2::setObjectProperty for objectIndex(string objectIndex) with propertyId(string propertyId) to value(string  value) (warp=false)
{
    If (objectIndex == 0)
    {
        Call Not implemented yet("setObjectProperty: Returning zero (1)");
    }
    Call dataIndex = GameDatabaseV2::findObjectProperty for objectIndex(objectIndex) with propertyId(propertyId);
    If (dataIndex > 0)
    {
        List.ReplaceItem(ObjectV2::_objData, dataIndex, ( value % 256));
        List.ReplaceItem(ObjectV2::_objData, (dataIndex + 1), floor(( value / 256)));
        value =  value;
        Stop(this script);
    }
    Else
    {
        value = 0;
        Stop(this script);
    }
}

Define value = SeekableReadStream::readUint16LE (warp=false)
{
    value = (_dat[(sourceS + 1)] + (_dat[(sourceS + 2)] * 256));
    sourceS += 2;
}


//----- Orphaned blocks -----------------------------------------------------------------------------------------------

Call //("I'm using ObjectV2::objDataOffset for the Scratch implementation to monitor where each object starts in the data list")


//----- Costumes ------------------------------------------------------------------------------------------------------

costume1.svg


//----- Sounds --------------------------------------------------------------------------------------------------------

Meow.wav
